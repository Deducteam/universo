Nat : Type.

z : Nat.
s : Nat -> Nat.

(; Sorts ;)

Sort : Type.

prop : Sort.
type : Nat -> Sort.

True : Type.
I : True.

def Cumul : Sort -> Sort -> Type.
[s] Cumul prop s --> True.
[i] Cumul (type z) (type i) --> True.
[i,j] Cumul (type (s i)) (type (s j)) --> Cumul (type i) (type j).

def Rule : Sort -> Sort -> Sort -> Type.
[]  Rule _ prop prop --> True.
[i] Rule prop i i --> True.
[i] Rule (type i) (type z) (type i) --> True.
[j] Rule (type z) (type j) (type j) --> True.
[i,j,k] Rule (type (s i)) (type (s j)) (type (s k)) --> Rule (type i) (type j) (type k).

def Axiom : Sort -> Sort -> Type.
[] Axiom prop (type z) --> True.
[] Axiom (type z) (type (s z)) --> True.
[i,j] Axiom (type (s i)) (type (s j)) --> Axiom (type i) (type j).

(; Types and terms ;)

Univ : s : Sort -> Type.
def Term : s : Sort -> a : Univ s -> Type.


(; should be private ;)
univ' : s : Sort -> s' : Sort -> Univ s'.

def univ : s : Sort -> s' : Sort -> Axiom s s' -> Univ s'.
[s,s'] univ s s' _ --> univ' s s'.

(; should be private ;)
def lift' : s1 : Sort -> s2 : Sort -> Univ s1 -> Univ s2.

def lift : s1 : Sort -> s2 : Sort -> Cumul s1 s2 -> Univ s1 -> Univ s2.
[s1,s2,a] lift s1 s2 _ a --> lift' s1 s2 a.

(; should be private ;)
def prod' : s1 : Sort -> s2 : Sort -> s3 : Sort -> a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ s3.

def prod : s1 : Sort -> s2 : Sort -> s3 : Sort -> Rule s1 s2 s3 -> a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ s3.
[s1,s2,s3,a,b] prod s1 s2 s3 _ a b --> prod' s1 s2 s3 a b.

[s] Term _ (univ' s _) --> Univ s.
[s1, a] Term _ (lift' s1 _ a) --> Term s1 a.
[s1, s2, a, b] Term _ (prod' s1 s2 _ a b) --> x : Term s1 a -> Term s2 (b x).

(; Canonicity rules ;)

[s, a] lift' s s a --> a.
[s1, s2, s3, a] lift' _ s3 (lift' s1 s2 a) --> lift' s1 s3 a.
[s1, s2, s3, s4, a, b]
  prod' _ s2 s4 (lift' s1 s3 a) b --> lift' s3 s4 (prod' s1 s2 s3 a b).
[s1, s2, s3, s4, a, b]
  prod' s1 _ s4 a (x => lift' s2 s3 (b x)) --> lift' s3 s4 (prod' s1 s2 s3 a (x => b x)).
